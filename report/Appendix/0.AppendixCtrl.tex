\part{Appendix}
\input{Appendix/AppendixJones1.tex}
\input{Appendix/NPDA.tex}

\section{Aalborg Tekniske Gymnasium Student and Teacher Interview (In danish)}
\label{Interviews}
Projektstyring
Analog og digital teknik.
Programmerbar teknologi.
Næsten ingen programmering i faget.
Allerede har haft programmering: Visual basic og C++
- B-niveau: Variabler, typer, kontrolstrukturer. 


Projekter:
- Cykellygte,
- Spilprojekt på arduino,
- Motor (Robot),
- Censorprojektet,
- Eksamensprojekt.

Spørgsmål: 
- Lave en funktion (opbygning)
- Lang tid på fejlsøgning.

Snakker meget for visuel programmering.
Giver forståelse for de initielle aspekter.


- Semikolon: Måske - (Men ja)
- Typer: Brug begge dele.
- Static vs dynamic typed: Så længe det virker. (Fare for at gøre noget uhensigtsmæssigt.)

Faget: Ikke så meget forstå - mere bare lave. - Mindre fysik.

Er kurset i høj kurs: Har haft programmering -> vælger dette fag.

Digital design og udvikling (nyt fag, apps, spil, robotdesign)

Nogle skifter hurtigt. Andre har ingen erfaring, men vokser med opgaven.

Generelle hjælpelinjer:
- Nem tilkobling og interaktion med hw.

GPIO: LED - DC Motor. Nogle sensorer. Bluetooth.

Duden er hw fan.

=================================

Til elever:

Lidt C{\#} -> Programmering (C{\#})
Meget C{\#}
Godt lide computere, men programmering for "boxed" - Ikke skrive forkert. 
"Hyggeligt når det fungere"
Slet ingen programmering.
Opnået en del interesse igennem faget.
Linjefag. Alle har haft C{\#}.
Linjefag. C{\#} Programmering.
En rimelige skarp i javascript.

Programmering:
- Rigtige funtkionskald,
- Semikolon er fint - Det er okay (MEN PISSE TRÆLS NÅR MAN GLEMMER.)
- Arrays - 0-indexed forvirrende - arrays forvirrende.
- Var ikke brugt. -> auto brugt.
- Kender ikke funktionskald (Mange forskellige)
- Problemer med typer - (Type inference ville være nemmere) - Men kan godt lide eksplicit type.
- Semikolon ikke træls - Skulle være.
- Aner intet om typer 
- Ikke problemer med typer.
- C{\#} Let at gå til -> IDE'en. 
- C vs C{\#} i ide -> De mener at det ville være lige svært i en almindelig text editor.
- Loops var svære. Forskel på loops.
- Kunne ikke se pointe med metoder.
- Nemmere uden typer. Lidt svært at lære typer.
- Svært ikke at lære typer til start?
- Synes det var fint ikke at forholde sig til typer i start (brugte lua)
- Meget udenadslære, ikke tænke sig til hvilke kommandoer der gør hvad. Det kunne være bedre fra IDE'en.
- Loops er forvirrende. "For"-navnet er ikke intuitivt. 
- En med JS synes godt med var.
- Lang tid på at lære typerne.
- Kunne samle tal typer til num.

Hvad kunne være bedre?: 
- Dokumentationen kunne være bedre.
- Man er vant til overhead -> Så det okay, men lidt tvilende. Men de mener også det er fordi det er det de har lært, og det nok kunne være simplere for begyndere.
- Error beskeder lort.
- Smart med ikke include.
- Kan ikke huske hvordan man laver funktion, men de siger det altid nemt at se hvordan man gjorde sidst.
- Bedre dokumentation
- Overflod af metoder.
- Eksempler til sproget.
- Lidt problemer med header og includes.
- Scoping er lidt svært.
- Nem tilgang til muligt funktions kald.
- Godt med afgrænsning fra {}
- En forslår indentation som fra python.

Arduino platformen:
- Den er fin, IDE dårlig ikke hjælper.
- Minestorm forturkket af en der er "Dårlig" til programmering.
- Love it. Det er simpelt.
- Arduino er "Dum" gør hvad den bliver bedt om -> godt.
- Svært med for mange komponenter, men generelt god læringsplatform.
- Godt med hands-on experience. Bedre med noget fysisk, end bare en terminal fra C{\#}.
- Svært med hvad forskellige gpio og ports gør.
- Ideen med at man får noget til at "Lyse" er fed!
- Fejlbeskeder er dårlige.
- Editoren burde hjælpe mere.


Læse videre:
- Software
- Nanoteknologi
- Maskinmester
- Programmering (Presset mod det.)
- Datalog 
- Bedre sprog kunne have øget interesse.
- Maskinmester
- En ville lave hjemmesider, men synes programmering ikke var underholdende, fordi læringskurve var for stejl.
- Vil gerne hurtigere nå målet.
- Sidste gruppe snakker rigtig meget for at et nemmere sprog kunne have øget interessen, og at de er blevet skræmt lidt væk.
- En software ingeniør. 


- Vores sprog: 
- Ikke så synligt for dem. Men efter forklaring gav mening.

- Første 3 gik meget hurtigt og klar igennem, 4 var lidt mere besværlig. Hjalp med parenteser.

- Gruppe løste alle 4 opgaver.(Denne gruppe havde IKKE programmeret før)

- Denne gruppe acede det. Stadig en smule problemer med associering.

- Sidste gruppe var rimelig god, men stadig lidt tvivl om associering.

\section{Extended Backus-Naur Form of HCL grammar}
\label{AppendixEBNF}
\begin{align*}
	\texttt{<Program>}\to & \texttt{ <Cmds> \$}\\
	\texttt{<Cmds>}\to & \texttt{ \{<Cmd>\}}\\
	\texttt{<Cmd>}\to & \texttt{ <VarDcl> linebreak}\\
	| & \texttt{ <Assign> linebreak}\\
	| & \texttt{ <Expr> linebreak}\\
	| & \texttt{ <ReturnCmd> linebreak}\\
	\texttt{<Dcl>}\to & \texttt{ <ImplicitType> identifier [equals <DclValue>]}\\
	\texttt{<ImplicitType>}\to & \texttt{ <Type>}\\
	| & \texttt{ func}\\
	| & \texttt{ var}\\
	\texttt{<Type>}\to & \texttt{ number}\\
	| & \texttt{ text}\\
	| & \texttt{ tuple sqBracketL [<TypeList>] sqBracketR}\\
	| & \texttt{ list sqBracketL [<Type>] sqBracketR}\\
	| & \texttt{ bool}\\
	| & \texttt{ func sqBracketL [<TypeListNoneAndGenerics>] sqBracketR}\\
	| & \texttt{ none}\\
	\texttt{<TypeList>}\to & \texttt{ <Type> [comma <TypeList>]}\\
	\texttt{<TypeListGenerics>}\to & \texttt{ <TypeGenerics> [separator <TypeListGenerics>] }\\
	\texttt{<TypeNoneAndGenerics>}\to & \texttt{<TypeGenerics>}\\
	| & \texttt{ none}\\
	\texttt{<TypeListNoneAndGenerics>} \to & \texttt{ <TypeNoneAndGenerics> [separator <TypeListNoneAndGenerics>]}\\
	\texttt{<TypeGenerics>}\to & \texttt{<Type>}\\
	| & \texttt{ identifier}\\
	\texttt{<Expr>}\to & \texttt{ <FunctionCall>}\\
	| & \texttt{ <Value>}\\
	| & \texttt{ parenL <Expr> parenR }\\
	\texttt{<Value>}\to & \texttt{ <Literal>}\\
	| & \texttt{ identifier}\\
	\texttt{<Literal>}\to & \texttt{ literalNumber}\\
	| & \texttt{ literalText}\\
	| & \texttt{ literalBool}\\
	| & \texttt{ <LiteralTuple>}\\
	| & \texttt{ <LiteralList>}\\
	\texttt{<Values>}\to & \texttt{ <Value> [comma <Values>]}\\
\end{align*} %pagebreak
\begin{align*}
	\texttt{<LiteralTuple>}\to & \texttt{ parenL <Values> parenR}\\
	\texttt{<LiteralList>}\to & \texttt{ sqBracketL <Values> sqBracketR}\\
	\texttt{<DclValue>}\to & \texttt{ <Expr>}\\
	| & \texttt{ <LambdaExpr>}\\
	\texttt{<Assign>}\to & \texttt{ identifier equals <DclValue>}\\
	\texttt{<LambdaExpr>}\to & \texttt{ parenL [<FunDclParams>] parenR colon <TypeNoneAndGenerics> {linebreak} <LambdaBody>}\\
	\texttt{<LambdaBody>}\to & \texttt{ curlyL <Cmds> curlyR}\\
	\texttt{<FunDclParams>}\to & \texttt{ <FunDclParam> [comma <FunDclParams>]}\\
	\texttt{<FunDclParam>}\to & \texttt{ <TypeListGenerics> identifier}\\
	\texttt{<FunctionCall>}\to & \texttt{ identifier}\\
	| & \texttt{ <Arg> identifier [<Args>]}\\
	\texttt{<Args>}\to & \texttt{ \{<Arg>\}+}\\
	| & \texttt{ parenL \{<Arg>\}+ parenR}\\
	\texttt{<Arg>}\to & \texttt{[colon]<Value>}\\
	| & \texttt{ <LambdaExpr>}\\
	| & \texttt{ <LambdaBody>}\\
	\texttt{<ReturnCmd>}\to & \texttt{ return <Expr>}
\end{align*}
\newpage
\input{Appendix/BuiltInFunctionsAppend.tex}
\input{Appendix/SemanticsTree.tex}
\input{Appendix/TypeTree.tex}